using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Exercise1
{
    /// <summary>
    /// Class rappresenting a Deterministic Automata
    /// </summary>
    public class DAutomata : IAutomata<DAutomata.DAutomataState>
    {
        #region Private variables

        // static int for unique array generator
        private static int _curIDState = 0;

        // "static" array of internal symbols for this automata
        private string[] _arrChars;

        // "static" array of states generated by InitializeStartState()
        private DAutomataState[] _arrStates;

        // initial state for this automata
        private DAutomataState _startState;

        #endregion

        #region Constructor

        public DAutomata(DAutomataState startState)
        {
            InitializeStartState(startState);
        }

        #endregion

        #region Private methods

        /// <summary>
        /// Initialize the automata enumerating the states from 0 to n (number of internal states) and set stState as StartState
        /// </summary>
        /// <param name="startState">Initial state for this automata</param>
        public void InitializeStartState(DAutomata.DAutomataState startState)
        {
            List<DAutomataState> _lstStates = new List<DAutomataState>();

            foreach (var st in GenerateStatesFromStartState(startState))
            {
                if (!_lstStates.Contains(st)) _lstStates.Add(st);
            }
            DAutomata.ResetID();

            DAutomataState initialState = _lstStates[_lstStates.IndexOf(startState)];
            if (initialState == null)
                throw new Exception("Start state " + startState.ToString() + " is not an automata state");

            initialState.ID = DAutomata.GetNextID();
            foreach (var state in _lstStates)
            {
                if (state != initialState)
                    state.ID = DAutomata.GetNextID();
            }
            _startState = initialState;
            _arrStates = _lstStates.ToArray();
            _arrChars = GetChars().ToArray();
        }

        /// <summary>
        /// Reset the ID production to 0
        /// </summary>
        private static void ResetID()
        {
            _curIDState = 0;
        }

        /// <summary>
        /// Gets a new unique id from the last ResetID() call
        /// </summary>
        /// <returns>Unique ID</returns>
        private static int GetNextID()
        {
            return _curIDState++;
        }

        /// <summary>
        /// Useful function to generate all the states from the first state
        /// </summary>
        /// <param name="stateStart"></param>
        /// <returns></returns>
        private static DAutomata.DAutomataState[] GenerateStatesFromStartState(DAutomata.DAutomataState stateStart)
        {
            List<DAutomata.DAutomataState> lstResults = new List<DAutomata.DAutomataState>();
            Stack<DAutomata.DAutomataState> statesStack = new Stack<DAutomata.DAutomataState>();

            statesStack.Push(stateStart);

            while (statesStack.Count > 0)
            {
                DAutomata.DAutomataState state = statesStack.Pop();
                if (!lstResults.Contains(state)) lstResults.Add(state);

                foreach (var curSymbol in state.GetAllChars())
                {
                    DAutomata.DAutomataState trans = state.GetTransition(curSymbol);
                    if (trans != null && !lstResults.Contains(trans))
                    {
                        if (!statesStack.Contains(trans)) statesStack.Push(trans);
                    }
                }
            }

            return lstResults.ToArray();
        }

        /// <summary>
        /// Used to generate the list of all automata chars
        /// </summary>
        /// <returns>Strings array containing all the used chars in this automata</returns>
        private string[] GetChars()
        {
            List<string> _result = new List<string>();
            foreach (var st in _arrStates)
            {
                _result = _result.Union(st.GetAllChars()).ToList();
            }
            return _result.ToArray();
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets the states set
        /// </summary>
        public DAutomata.DAutomataState[] States
        {
            get { return _arrStates; }
        }

        /// <summary>
        /// Gets the chars used for this automata
        /// </summary>
        public string[] Chars
        {
            get { return _arrChars; }
        }

        /// <summary>
        /// Get the initial stat for this DF Automata
        /// </summary>
        public DAutomataState StartState
        {
            get { return _startState; }
        }

        #endregion

        #region Automata subclasses

        /// <summary>
        /// Class to rappresent a transition from char to NextState
        /// </summary>
        public class DFTransition
        {
            KeyValuePair<string, DAutomataState> _internalState;
            public DFTransition(string matchedChar, DAutomataState nextState)
            {
                _internalState = new KeyValuePair<string, DAutomataState>(matchedChar, nextState);
            }

            public string MatchedChar
            {
                get { return _internalState.Key; }
            }

            public DAutomataState NextState
            {
                get { return _internalState.Value; }
                set { _internalState = new KeyValuePair<string, DAutomataState>(_internalState.Key, value); }
            }

            public override bool Equals(object obj)
            {
                try
                {
                    DFTransition _temp = (DFTransition)obj;
                    return _temp.MatchedChar == this.MatchedChar;
                }
                catch
                {
                    return false;
                }
            }

            // to suppress  the unoverride warning
            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                return this.MatchedChar;
            }
        }

        /// <summary>
        /// class to rappresent an automata state
        /// </summary>
        public class DAutomataState : IAutomataState<DAutomataState>
        {
            static int _staticId = 0;
            // Set of transition objects
            private List<DFTransition> _transitionFunction;
            private int _id = 0;
            private bool _isFinal = false;

            public DAutomataState()
            {
                _transitionFunction = new List<DFTransition>();
                _id = DAutomata.DAutomataState.GetNextID();
            }

            public int ID
            {
                get { return _id; }
                set { _id = value; }
            }

            public DFTransition[] Transitions
            {
                get { return _transitionFunction.ToArray(); }
            }

            #region Internal methods

            /// <summary>
            /// List of all chars that chan match with this state
            /// </summary>
            /// <returns>List of matched chars</returns>
            internal List<string> GetAllChars()
            {
                List<string> _result = new List<string>();
                foreach (var st in _transitionFunction)
                {
                    if (!_result.Contains(st.MatchedChar)) _result.Add(st.MatchedChar);
                }
                return _result;
            }

            /// <summary>
            /// Get a new unique ID for this state
            /// </summary>
            /// <returns>Unique ID</returns>
            internal static int GetNextID()
            {
                return _staticId++;
            }

            #endregion

            #region Public methods



            public DAutomataState GetTransition(string sCharToMatch)
            {
                DFTransition _temp = new DFTransition(sCharToMatch, null);
                if (_transitionFunction.Contains(_temp))
                {
                    return _transitionFunction[_transitionFunction.IndexOf(_temp)].NextState;
                }
                return null;
            }

            public DAutomataState AddTransition(string cMatchedChar, DAutomataState sNextState)
            {
                DFTransition newT = new DFTransition(cMatchedChar, sNextState);
                if (_transitionFunction.Contains(newT)) // already exists an association for this char in this state
                {
                    _transitionFunction[_transitionFunction.IndexOf(newT)].NextState = sNextState;
                }
                else // first association for this char
                {
                    newT.NextState = sNextState;
                    _transitionFunction.Add(newT);
                }
                return this;

            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="stateOld"></param>
            /// <param name="stateNew"></param>
            /// <returns></returns>
            public int ReplaceTransitionState(DAutomataState stateOld, DAutomataState stateNew)
            {
                int nReplacementCount = 0;
                foreach (var de in _transitionFunction)
                {
                    if (de.NextState == stateOld)
                    {
                        de.NextState = stateNew;
                        nReplacementCount++;
                    }
                }
                return nReplacementCount;
            }

            /// <summary>
            /// Return true if this state is a dead stare
            /// </summary>
            /// <returns></returns>
            public bool IsDeadState()
            {
                // final states are not dead states
                if (IsFinal) return false;

                // if no chars are matched with this state it's not a dead state
                if (_transitionFunction.Count == 0) return false;

                foreach (var de in _transitionFunction)
                {
                    // if not exists a loop (this --> nextstate --> this) it's not a dead state
                    if (de.NextState != this) return false;
                }
                return true;
            }

            /// <summary>
            /// A string rappresentation for an automata state
            /// </summary>
            /// <returns>"{sID}" if this state is final or "sID" otherwise</returns>
            public override string ToString()
            {
                string s = "s" + this.ID.ToString();
                if (IsFinal) s = "{" + s + "}";
                return s;
            }

            /// <summary>
            /// Check if this state is equals to obj state
            /// </summary>
            /// <param name="obj">an object of DAutomataState type to compare with</param>
            /// <returns></returns>
            public override bool Equals(object obj)
            {
                DAutomataState _temp = (DAutomataState)obj;
                return _temp.ID == this.ID;
            }

            // to suppress  the unoverride warning
            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            #endregion

            #region Properties

            /// <summary>
            /// Return true if this state is a final (accepting) state
            /// </summary>
            public bool IsFinal
            {
                get { return _isFinal; }
                set { _isFinal = value; }
            }

            #endregion
        }

        #endregion
    }
}
